package application;
import javafx.fxml.Initializable;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.MenuItem;
import javafx.scene.control.TextField;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.stage.Stage;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import java.io.IOException;
import java.net.URL;
import java.time.Duration;
import java.time.LocalDate;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.util.ResourceBundle;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Collections;


public class BookinfoController implements Initializable{
    @FXML
    private TextField search_textfield;
	@FXML
	private Button btn_search;
    @FXML
    private TableView<model.SelectedGenre> tableview;
    @FXML
    private TableColumn<?, ?> ISBN;
    @FXML
    private TableColumn<?, ?> bookname;
    @FXML
    private TableColumn<?, ?> author;
    @FXML
    private TableColumn<?, ?> publisher;
    @FXML
    private TableColumn<?, ?> publishDate;
    @FXML
    private TableColumn<?, ?> genre;
    @FXML
    private TableColumn<?, ?> amount;
    @FXML
    private TableColumn<?, ?> stock;
    @FXML
    private TableColumn<?, ?> bookID;
	@FXML
	private MenuItem borrow10days;
	@FXML
	private MenuItem borrow20days;
	@FXML
	private MenuItem borrow30days;
	@FXML
	private Button btn_reserve;
	@FXML
	private Button btn_homepage;

	
	public void initialize(URL url, ResourceBundle bundle) {
		try {
			if(!session.Session.getSelected_genre().isEmpty()) {// user searched by genre selected in previous page
				ArrayList<String> genres = session.Session.getSelected_genre();
				ISBN.setCellValueFactory(new PropertyValueFactory<>("bookIsbn"));
				bookname.setCellValueFactory(new PropertyValueFactory<>("bookname"));
	            author.setCellValueFactory(new PropertyValueFactory<>("author"));
	            publisher.setCellValueFactory(new PropertyValueFactory<>("publisher"));
	            publishDate.setCellValueFactory(new PropertyValueFactory<>("publishDate"));
	            genre.setCellValueFactory(new PropertyValueFactory<>("genre"));
	            amount.setCellValueFactory(new PropertyValueFactory<>("amount"));
	            stock.setCellValueFactory(new PropertyValueFactory<>("stock"));
	            bookID.setCellValueFactory(new PropertyValueFactory<>("bookId"));
	            ObservableList<model.SelectedGenre> data = FXCollections.observableArrayList();
	            
	            String genrePlaceholder = String.join(",", Collections.nCopies(genres.size(), "?"));
	            String sql = "SELECT bookinfo.ISBN, bookname, author, publisher, publishDate, genre, amount, inStock, bookID " +
	                         "FROM bookinfo, book " +
	                         "WHERE bookinfo.ISBN = book.ISBN AND genre IN (" + genrePlaceholder + ") " +
	                         "GROUP BY genre, bookID";

	            PreparedStatement stmt = connectMysql.Connnector.executePreparedStatement(sql);
	            for (int i = 0; i < genres.size(); i++) {
	                stmt.setString(i + 1, genres.get(i));
	            }
	            ResultSet rs = stmt.executeQuery();
	            while(rs.next()) {
	            	String bookIsbn = rs.getString("ISBN");
	            	String bookname = rs.getString("bookname");
	            	String author = rs.getString("author");
	            	String publisher = rs.getString("publisher");
	            	String publishDate = rs.getDate("publishDate")+"";
	            	String genre = rs.getString("genre");
	            	int amount = rs.getInt("amount");
	            	int stock = rs.getInt("inStock");
	            	String bookId = rs.getString("bookID");
	            	data.add(new model.SelectedGenre(bookIsbn,bookname,author,publisher,publishDate,genre,amount,stock,bookId));
	            }
	            tableview.setItems(data);
			}
			else {
				Alert alert = new Alert(AlertType.INFORMATION);
				alert.setContentText("please enter ISBN,bookname or author to search books");
				alert.showAndWait();
			}
		}
		catch(Exception e) {
			e.printStackTrace();
		}
		finally {
			session.Session.clearSelected_genre();// clear selected genres
		}
	}
	// Event Listener on Button[#btn_search].onAction
	@FXML
	public void clicktoSearch(ActionEvent event) {
		// TODO Autogenerated
		try {
		String text = search_textfield.getText();
		String sql = "SELECT bookinfo.ISBN, bookname, author, publisher, publishDate, genre, amount, inStock, bookID " +
                "FROM bookinfo, book " +"WHERE bookinfo.ISBN = book.ISBN AND (bookinfo.ISBN like ? or bookname like ? or author like ?)" +
                "GROUP BY bookinfo.ISBN";
		PreparedStatement stmt = connectMysql.Connnector.executePreparedStatement(sql);
		stmt.setString(1, "%"+text+"%");
		stmt.setString(2, "%"+text+"%");
		stmt.setString(3, "%"+text+"%");
		ResultSet rs = stmt.executeQuery();
		ObservableList<model.SelectedGenre> data = FXCollections.observableArrayList();
		while(rs.next()) {
			String bookIsbn = rs.getString("ISBN");
        	String bookname = rs.getString("bookname");
        	String author = rs.getString("author");
        	String publisher = rs.getString("publisher");
        	String publishDate = rs.getDate("publishDate")+"";
        	String genre = rs.getString("genre");
        	int amount = rs.getInt("amount");
        	int stock = rs.getInt("inStock");
        	String bookId = rs.getString("bookID");
        	data.add(new model.SelectedGenre(bookIsbn,bookname,author,publisher,publishDate,genre,amount,stock,bookId));
		}
		tableview.setItems(data);
		}
		catch(Exception e) {
			e.printStackTrace();
		}
	}
	// Event Listener on MenuItem[#borrow10days].onAction
	@FXML
	public void clicktoBorrow10days(ActionEvent event) {
		// TODO Autogenerated
		try {
			
			ObservableList<model.SelectedGenre> data = tableview.getSelectionModel().getSelectedItems();
			String bookId = data.get(0).getBookId();// user could only borrow 1 book/time,so use get(0)
			String ISBN = data.get(0).getBookIsbn();
			String id = session.Session.getUserID();
			String sql = "select credits from user where ID=?";
			PreparedStatement stmt = connectMysql.Connnector.executePreparedStatement(sql);
			stmt.setString(1, id);
			ResultSet rs = stmt.executeQuery();
			int credits=0;
			while(rs.next()) {
				credits = rs.getInt("credits");
			}
			String condition = "";
			String getCondition = "select `condition` from book where bookID=?";
			stmt = connectMysql.Connnector.executePreparedStatement(getCondition);
			stmt.setString(1, bookId);
			rs = stmt.executeQuery();
			while(rs.next()) {
				condition = rs.getString("condition");
			}
			boolean hasOverdue = false;
			String getBrid = "select brID from br_record where UID=?";
			stmt = connectMysql.Connnector.executePreparedStatement(getBrid);
			stmt.setString(1, id);
			rs = stmt.executeQuery();
			while(rs.next() && (!hasOverdue)) {// check every brID of this user
				int br_id = rs.getInt("brID");
				String validation = "select borrowDate, duration from br_record where brID=? and returnDate is null";
				stmt = connectMysql.Connnector.executePreparedStatement(validation);
				stmt.setInt(1, br_id);
				ResultSet result = stmt.executeQuery();
				result.next();
				Date borrow_date = result.getDate("borrowDate");
				int duration = Integer.valueOf(result.getString("duration").substring(0, 2));
				LocalDate localDate_borrow = borrow_date.toLocalDate();
		        LocalDate localDate_current = Date.valueOf(new model.CurrentDate().toString()).toLocalDate();
		        Duration length = Duration.between(localDate_borrow.atStartOfDay(), localDate_current.atStartOfDay());
		        int realDuration = (int)length.toDays();
		        if(realDuration > duration) {
		        	hasOverdue = true;
		        	break;
		        }
			}
			if( ( credits<=0 || ( condition.equals("borrowed") ) ) || hasOverdue ) {
				Alert alert = new Alert(AlertType.WARNING);
				alert.setContentText("Either your credits is less than 0 or you have books that not returned are overdue, so you can't use borrow function now, (please go to reception to pay cash"+
				"to ransom your credits) or the book is not available now.Check your profile and the borrow page to see details.");
				alert.showAndWait();
			}
// reserve function to be implemented:check bookID to see whether it is reserved. Then check whether the user is the one who reserved the book
			else {
				String checkID = "select * from reservation where bookID=?";
				stmt = connectMysql.Connnector.executePreparedStatement(checkID);
				stmt.setString(1, bookId);
				rs = stmt.executeQuery();
				if(rs.next()) {//if book has been reserved
					if(!rs.getString("UID").equals(id)) {// not reserved by current user
						Alert alert = new Alert(AlertType.WARNING);
						alert.setContentText("This book has been reserve by others!");
						alert.showAndWait();
						}
					else {// reserved by current user
						String setCondition = "UPDATE `library_management_system`.`book` SET `condition` = 'borrowed' WHERE (`bookID` = ?)";
						stmt = connectMysql.Connnector.executePreparedStatement(setCondition);
						stmt.setString(1, bookId);
						stmt.executeUpdate();// update the book condition to 'borrowed'
						
						String setStock = "update bookinfo set inStock=inStock-1 where ISBN=?";
						stmt = connectMysql.Connnector.executePreparedStatement(setStock);
						stmt.setString(1, ISBN);
						stmt.executeUpdate();// update the stock of the book
						
						String insert_sql = "INSERT INTO br_record(`UID`, `bookID`, `duration`, `borrowDate`) VALUES (?, ?, ?, ?)";
						String d = new model.CurrentDate().toString();
						Date date = Date.valueOf(d);// String convert into a sql.Date type variable
						stmt = connectMysql.Connnector.executePreparedStatement(insert_sql);
						stmt.setString(1,id);
						stmt.setString(2,bookId);
						stmt.setString(3, "10days");
						stmt.setDate(4, date);
						stmt.executeUpdate();// insert borrow record into br_record table
						
						String delReserve = "delete from reservation where bookID=?";
						stmt = connectMysql.Connnector.executePreparedStatement(delReserve);
						stmt.setString(1, bookId);
						stmt.executeUpdate();//delete record in reservation table
						
						Alert alert = new Alert(AlertType.INFORMATION);
						alert.setContentText("Your have borrowed this book successfully!");
						alert.showAndWait();
						
					}
				}
				else{// book has not been reserved
				String setCondition = "UPDATE `library_management_system`.`book` SET `condition` = 'borrowed' WHERE (`bookID` = ?)";
				stmt = connectMysql.Connnector.executePreparedStatement(setCondition);
				stmt.setString(1, bookId);
				stmt.executeUpdate();// update the book condition to 'borrowed'
				
				String setStock = "update bookinfo set inStock=inStock-1 where ISBN=?";
				stmt = connectMysql.Connnector.executePreparedStatement(setStock);
				stmt.setString(1, ISBN);
				stmt.executeUpdate();// update the stock of the book
				
				String insert_sql = "INSERT INTO br_record(`UID`, `bookID`, `duration`, `borrowDate`) VALUES (?, ?, ?, ?)";
				String d = new model.CurrentDate().toString();
				Date date = Date.valueOf(d);// String convert into a sql.Date type variable
				stmt = connectMysql.Connnector.executePreparedStatement(insert_sql);
				stmt.setString(1,id);
				stmt.setString(2,bookId);
				stmt.setString(3, "10days");
				stmt.setDate(4, date);
				stmt.executeUpdate();// insert borrow record into br_record table
				
				Alert alert = new Alert(AlertType.INFORMATION);
				alert.setContentText("Your have borrowed this book successfully!");
				alert.showAndWait();
				}
			}
			stmt.close();
			rs.close();
		}
		catch(Exception e) {
			e.printStackTrace();
		}
	}
	// Event Listener on MenuItem[#borrow20days].onAction
	@FXML
	public void clicktoBorrow20days(ActionEvent event) {
		// TODO Autogenerated
try {
			
	ObservableList<model.SelectedGenre> data = tableview.getSelectionModel().getSelectedItems();
	String bookId = data.get(0).getBookId();// user could only borrow 1 book/time,so use get(0)
	String ISBN = data.get(0).getBookIsbn();
	String id = session.Session.getUserID();
	String sql = "select credits from user where ID=?";
	PreparedStatement stmt = connectMysql.Connnector.executePreparedStatement(sql);
	stmt.setString(1, id);
	ResultSet rs = stmt.executeQuery();
	int credits=0;
	while(rs.next()) {
		credits = rs.getInt("credits");
	}
	String condition = "";
	String getCondition = "select `condition` from book where bookID=?";
	stmt = connectMysql.Connnector.executePreparedStatement(getCondition);
	stmt.setString(1, bookId);
	rs = stmt.executeQuery();
	while(rs.next()) {
		condition = rs.getString("condition");
	}
	boolean hasOverdue = false;
	String getBrid = "select brID from br_record where UID=?";
	stmt = connectMysql.Connnector.executePreparedStatement(getBrid);
	stmt.setString(1, id);
	rs = stmt.executeQuery();
	while(rs.next() && (!hasOverdue)) {// check every brID of this user
		int br_id = rs.getInt("brID");
		String validation = "select borrowDate, duration from br_record where brID=? and returnDate is null";
		stmt = connectMysql.Connnector.executePreparedStatement(validation);
		stmt.setInt(1, br_id);
		ResultSet result = stmt.executeQuery();
		result.next();
		Date borrow_date = result.getDate("borrowDate");
		int duration = Integer.valueOf(result.getString("duration").substring(0, 2));
		LocalDate localDate_borrow = borrow_date.toLocalDate();
        LocalDate localDate_current = Date.valueOf(new model.CurrentDate().toString()).toLocalDate();
        Duration length = Duration.between(localDate_borrow.atStartOfDay(), localDate_current.atStartOfDay());
        int realDuration = (int)length.toDays();
        if(realDuration > duration) {
        	hasOverdue = true;
        	break;
        }
	}
	if( ( credits<=0 || ( condition.equals("borrowed") ) ) || hasOverdue ) {
		Alert alert = new Alert(AlertType.WARNING);
		alert.setContentText("Either your credits is less than 0 or you have books that not returned are overdue, so you can't use borrow function now, (please go to reception to pay cash"+
		"to ransom your credits) or the book is not available now.Check your profile and the borrow page to see details.");
		alert.showAndWait();
	}
// reserve function to be implemented:check bookID to see whether it is reserved. Then check whether the user is the one who reserved the book
			else {
				String checkID = "select * from reservation where bookID=?";
				stmt = connectMysql.Connnector.executePreparedStatement(checkID);
				stmt.setString(1, bookId);
				rs = stmt.executeQuery();
				if(rs.next()) {//if book has been reserved
					if(!rs.getString("UID").equals(id)) {// not reserved by current user
						Alert alert = new Alert(AlertType.WARNING);
						alert.setContentText("This book has been reserve by others!");
						alert.showAndWait();
						}
					else {// reserved by current user
						String setCondition = "UPDATE `library_management_system`.`book` SET `condition` = 'borrowed' WHERE (`bookID` = ?)";
						stmt = connectMysql.Connnector.executePreparedStatement(setCondition);
						stmt.setString(1, bookId);
						stmt.executeUpdate();// update the book condition to 'borrowed'
						
						String setStock = "update bookinfo set inStock=inStock-1 where ISBN=?";
						stmt = connectMysql.Connnector.executePreparedStatement(setStock);
						stmt.setString(1, ISBN);
						stmt.executeUpdate();// update the stock of the book
						
						String insert_sql = "INSERT INTO br_record(`UID`, `bookID`, `duration`, `borrowDate`) VALUES (?, ?, ?, ?)";
						String d = new model.CurrentDate().toString();
						Date date = Date.valueOf(d);// String convert into a sql.Date type variable
						stmt = connectMysql.Connnector.executePreparedStatement(insert_sql);
						stmt.setString(1,id);
						stmt.setString(2,bookId);
						stmt.setString(3, "20days");
						stmt.setDate(4, date);
						stmt.executeUpdate();// insert borrow record into br_record table
						
						String delReserve = "delete from reservation where bookID=?";
						stmt = connectMysql.Connnector.executePreparedStatement(delReserve);
						stmt.setString(1, bookId);
						stmt.executeUpdate();//delete record in reservation table
						
						Alert alert = new Alert(AlertType.INFORMATION);
						alert.setContentText("Your have borrowed this book successfully!");
						alert.showAndWait();
						
					}
				}
				else{
				String setCondition = "UPDATE `library_management_system`.`book` SET `condition` = 'borrowed' WHERE (`bookID` = ?)";
				stmt = connectMysql.Connnector.executePreparedStatement(setCondition);
				stmt.setString(1, bookId);
				stmt.executeUpdate();// update the book condition to 'borrowed'
				
				String setStock = "update bookinfo set inStock=inStock-1 where ISBN=?";
				stmt = connectMysql.Connnector.executePreparedStatement(setStock);
				stmt.setString(1, ISBN);
				stmt.executeUpdate();// update the stock of the book
				
				String insert_sql = "INSERT INTO br_record(`UID`, `bookID`, `duration`, `borrowDate`) VALUES (?, ?, ?, ?)";
				String d = new model.CurrentDate().toString();
				Date date = Date.valueOf(d);// String convert into a sql.Date type variable
				stmt = connectMysql.Connnector.executePreparedStatement(insert_sql);
				stmt.setString(1,id);
				stmt.setString(2,bookId);
				stmt.setString(3, "20days");
				stmt.setDate(4, date);
				stmt.executeUpdate();// insert borrow record into br_record table
				
				Alert alert = new Alert(AlertType.INFORMATION);
				alert.setContentText("Your have borrowed this book successfully!");
				alert.showAndWait();
				}
			}
			stmt.close();
			rs.close();
		}
		catch(Exception e) {
			e.printStackTrace();
		}
	}
	// Event Listener on MenuItem[#borrow30days].onAction
	@FXML
	public void clicktoBorrow30days(ActionEvent event) {
		// TODO Autogenerated
try {
			
	ObservableList<model.SelectedGenre> data = tableview.getSelectionModel().getSelectedItems();
	String bookId = data.get(0).getBookId();// user could only borrow 1 book/time,so use get(0)
	String ISBN = data.get(0).getBookIsbn();
	String id = session.Session.getUserID();
	String sql = "select credits from user where ID=?";
	PreparedStatement stmt = connectMysql.Connnector.executePreparedStatement(sql);
	stmt.setString(1, id);
	ResultSet rs = stmt.executeQuery();
	int credits=0;
	while(rs.next()) {
		credits = rs.getInt("credits");
	}
	String condition = "";
	String getCondition = "select `condition` from book where bookID=?";
	stmt = connectMysql.Connnector.executePreparedStatement(getCondition);
	stmt.setString(1, bookId);
	rs = stmt.executeQuery();
	while(rs.next()) {
		condition = rs.getString("condition");
	}
	boolean hasOverdue = false;
	String getBrid = "select brID from br_record where UID=?";
	stmt = connectMysql.Connnector.executePreparedStatement(getBrid);
	stmt.setString(1, id);
	rs = stmt.executeQuery();
	while(rs.next() && (!hasOverdue)) {// check every brID of this user
		int br_id = rs.getInt("brID");
		String validation = "select borrowDate, duration from br_record where brID=? and returnDate is null";
		stmt = connectMysql.Connnector.executePreparedStatement(validation);
		stmt.setInt(1, br_id);
		ResultSet result = stmt.executeQuery();
		result.next();
		Date borrow_date = result.getDate("borrowDate");
		int duration = Integer.valueOf(result.getString("duration").substring(0, 2));
		LocalDate localDate_borrow = borrow_date.toLocalDate();
        LocalDate localDate_current = Date.valueOf(new model.CurrentDate().toString()).toLocalDate();
        Duration length = Duration.between(localDate_borrow.atStartOfDay(), localDate_current.atStartOfDay());
        int realDuration = (int)length.toDays();
        if(realDuration > duration) {
        	hasOverdue = true;
        	break;
        }
	}
	if( ( credits<=0 || ( condition.equals("borrowed") ) ) || hasOverdue ) {
		Alert alert = new Alert(AlertType.WARNING);
		alert.setContentText("Either your credits is less than 0 so you can't use borrow function now, (please go to reception to pay cash"+
		"to ransom your credits) or the book has been borrowed, or you have overdue books not returned.Check your profile and the borrow page to see details.");
		alert.showAndWait();
	}
// reserve function to be implemented:check bookID to see whether it is reserved. Then check whether the user is the one who reserved the book
			else {
				String checkID = "select * from reservation where bookID=?";
				stmt = connectMysql.Connnector.executePreparedStatement(checkID);
				stmt.setString(1, bookId);
				rs = stmt.executeQuery();
				if(rs.next()) {//if book has been reserved
					if(!rs.getString("UID").equals(id)) {// not reserved by current user
						Alert alert = new Alert(AlertType.WARNING);
						alert.setContentText("This book has been reserve by others!");
						alert.showAndWait();
						}
					else {// reserved by current user
						String setCondition = "UPDATE `library_management_system`.`book` SET `condition` = 'borrowed' WHERE (`bookID` = ?)";
						stmt = connectMysql.Connnector.executePreparedStatement(setCondition);
						stmt.setString(1, bookId);
						stmt.executeUpdate();// update the book condition to 'borrowed'
						
						String setStock = "update bookinfo set inStock=inStock-1 where ISBN=?";
						stmt = connectMysql.Connnector.executePreparedStatement(setStock);
						stmt.setString(1, ISBN);
						stmt.executeUpdate();// update the stock of the book
						
						String insert_sql = "INSERT INTO br_record(`UID`, `bookID`, `duration`, `borrowDate`) VALUES (?, ?, ?, ?)";
						String d = new model.CurrentDate().toString();
						Date date = Date.valueOf(d);// String convert into a sql.Date type variable
						stmt = connectMysql.Connnector.executePreparedStatement(insert_sql);
						stmt.setString(1,id);
						stmt.setString(2,bookId);
						stmt.setString(3, "30days");
						stmt.setDate(4, date);
						stmt.executeUpdate();// insert borrow record into br_record table
						
						String delReserve = "delete from reservation where bookID=?";
						stmt = connectMysql.Connnector.executePreparedStatement(delReserve);
						stmt.setString(1, bookId);
						stmt.executeUpdate();//delete record in reservation table
						
						Alert alert = new Alert(AlertType.INFORMATION);
						alert.setContentText("Your have borrowed this book successfully!");
						alert.showAndWait();
						
					}
				}
				else{
				String setCondition = "UPDATE `library_management_system`.`book` SET `condition` = 'borrowed' WHERE (`bookID` = ?)";
				stmt = connectMysql.Connnector.executePreparedStatement(setCondition);
				stmt.setString(1, bookId);
				stmt.executeUpdate();// update the book condition to 'borrowed'
				
				String setStock = "update bookinfo set inStock=inStock-1 where ISBN=?";
				stmt = connectMysql.Connnector.executePreparedStatement(setStock);
				stmt.setString(1, ISBN);
				stmt.executeUpdate();// update the stock of the book
				
				String insert_sql = "INSERT INTO br_record(`UID`, `bookID`, `duration`, `borrowDate`) VALUES (?, ?, ?, ?)";
				String d = new model.CurrentDate().toString();
				Date date = Date.valueOf(d);// String convert into a sql.Date type variable
				stmt = connectMysql.Connnector.executePreparedStatement(insert_sql);
				stmt.setString(1,id);
				stmt.setString(2,bookId);
				stmt.setString(3, "30days");
				stmt.setDate(4, date);
				stmt.executeUpdate();// insert borrow record into br_record table
				
				Alert alert = new Alert(AlertType.INFORMATION);
				alert.setContentText("Your have borrowed this book successfully!");
				alert.showAndWait();
				}
			}
			stmt.close();
			rs.close();
		}
		catch(Exception e) {
			e.printStackTrace();
		}
	}
	// Event Listener on Button[#btn_reserve].onAction
	@FXML
	public void clicktoReserve(ActionEvent event) {
		// TODO Autogenerated
		try {
		ObservableList<model.SelectedGenre> data = tableview.getSelectionModel().getSelectedItems();
		int credits = 0;
		String condition = "";
		String bookID = data.get(0).getBookId();
		String user_id = session.Session.getUserID();
		String checkCredits = "select credits from user where ID=?";
		// check credits > 0
		PreparedStatement state = connectMysql.Connnector.executePreparedStatement(checkCredits);
		state.setString(1, user_id);
		ResultSet rs = state.executeQuery();
		while(rs.next()) {
			credits = rs.getInt("credits");
		}
		boolean hasOverdue = false;
		String getBrid = "select brID from br_record where UID=?";
		state = connectMysql.Connnector.executePreparedStatement(getBrid);
		state.setString(1, user_id);
		rs = state.executeQuery();
		while(rs.next() && (!hasOverdue)) {// check every brID of this user
			int br_id = rs.getInt("brID");
			String validation = "select borrowDate, duration from br_record where brID=? and returnDate is null";
			state = connectMysql.Connnector.executePreparedStatement(validation);
			state.setInt(1, br_id);
			ResultSet result = state.executeQuery();
			result.next();
			Date borrow_date = result.getDate("borrowDate");
			int duration = Integer.valueOf(result.getString("duration").substring(0, 2));
			LocalDate localDate_borrow = borrow_date.toLocalDate();
	        LocalDate localDate_current = Date.valueOf(new model.CurrentDate().toString()).toLocalDate();
	        Duration length = Duration.between(localDate_borrow.atStartOfDay(), localDate_current.atStartOfDay());
	        int realDuration = (int)length.toDays();
	        if(realDuration > duration) {
	        	hasOverdue = true;
	        	break;
	        }
		}
		if(credits<=0 || hasOverdue) {
			Alert alert = new Alert(AlertType.WARNING);
			alert.setContentText("You don't have enough credits or you have overdue books not returned yet, so you can't use reservation function!");
			alert.showAndWait();
		}
		//credits is checked, now check condition = 'borrowed'
		else {
			String checkCon = "select `condition` from book where bookID=?";
			state = connectMysql.Connnector.executePreparedStatement(checkCon);
			state.setString(1,bookID);
			rs = state.executeQuery();
			while(rs.next()) {
				condition = rs.getString("condition");
			}
			if(!condition.equals("borrowed")) {
				Alert alert = new Alert(AlertType.WARNING);
				alert.setContentText("Only book that is borrowed can be reserved which means its stock = 0.");
				alert.showAndWait();
			}
			//condition is checked, now check if bookID has been in reservation table, which means it has already been reserved
			else {
				String checkBookID = "select * from reservation where bookID=?";
				state = connectMysql.Connnector.executePreparedStatement(checkBookID);
				state.setString(1, bookID);
				rs = state.executeQuery();
				if(rs.next()) {
					Alert alert = new Alert(AlertType.WARNING);
					alert.setContentText("This book has been reserved by other user, don't allow to be reserved");
					alert.showAndWait();
				}
				//bookID has been checked, now could make reservation
				else{
					String sql = "insert into reservation(`UID`, `bookID`) values(?,?)";
					state = connectMysql.Connnector.executePreparedStatement(sql);
					state.setString(1, user_id);
					state.setString(2, bookID);
					state.executeUpdate();// create reservation record, store the user id and bookid
					Alert alert = new Alert(AlertType.INFORMATION);
					alert.setContentText("This book has been reserved successfully! We will send your a email if it is available to borrow");
					alert.showAndWait();
				}
			}
		}
		
		}
		catch(Exception e) {
			e.printStackTrace();
		}
	}
	// Event Listener on Button[#btn_homepage].onAction
	@FXML
	public void clicktoHomepage(ActionEvent event) {
		// TODO Autogenerated
		try {
	    	 Parent homePage = FXMLLoader.load(getClass().getClassLoader().getResource("view/homepage.fxml"));

	         // Create a new scene with the next page content
	         Scene scene = new Scene(homePage);

	         // Get the current stage (primaryStage) from the button's scene
	         Stage primaryStage = (Stage) btn_homepage.getScene().getWindow();

	         // Set the new scene on the stage (Switch to the next page)
	         primaryStage.setScene(scene);
	         primaryStage.setResizable(false);
	         primaryStage.setTitle("homePage"); // Set the title of the next page
	         primaryStage.show();
				
	    	}
	    	catch(IOException e) {
	    		e.printStackTrace();
	    	}
	}
}
